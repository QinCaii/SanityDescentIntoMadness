name: Build and Release Minecraft Mod

on:
  push:
    branches:
      - '*'
  pull_request:
    branches:
      - '*'

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: 17
        distribution: 'temurin'

    - name: Cache Gradle packages
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-
    - name: Build with Gradle
      run: ./gradlew build

    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: build
        path: build/libs/*.jar

    - name: Ensure version file exists and create tag
      id: tag_version
      run: |
        VERSION_FILE="version.txt"
        
        # Ensure the version file exists or create a new one
        if [ ! -f "$VERSION_FILE" ]; then 
          echo "Creating version file with initial version 0.0.0"
          echo "0.0.0" > $VERSION_FILE; 
        fi
        
        # Read and increment the version number
        VERSION=$(cat $VERSION_FILE)
        IFS='.' read -r -a VERSION_PARTS <<< "$VERSION"
        MAJOR=${VERSION_PARTS[0]}
        MINOR=${VERSION_PARTS[1]}
        PATCH=${VERSION_PARTS[2]}
        
        # Increment the patch version
        PATCH=$((PATCH + 1))
        NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
        
        # Ensure the new tag is in the correct format
        TAG_NAME="v$NEW_VERSION"
        echo "Generated tag: $TAG_NAME"
        
        # Update version file
        echo $NEW_VERSION > $VERSION_FILE
        
        # Commit the new version and tag it
        git config --local user.name "GitHub Action"
        git config --local user.email "action@github.com"
        git add $VERSION_FILE
        git commit -m "Bump version to $NEW_VERSION"
        git tag -a "$TAG_NAME" -m "Version $NEW_VERSION"
        
        # Set output for the next steps
        echo "::set-output name=tag_name::$TAG_NAME"
    - name: Check if tag exists and handle conflicts
      id: check_tag
      run: |
        TAG_EXISTS=false
        while true; do
          if git ls-remote --tags origin | grep -q "refs/tags/${{ steps.tag_version.outputs.tag_name }}$"; then
            echo "Tag ${{ steps.tag_version.outputs.tag_name }} already exists"
            TAG_EXISTS=true
            # Increment the patch version again
            VERSION=$(cat $VERSION_FILE)
            IFS='.' read -r -a VERSION_PARTS <<< "$VERSION"
            MAJOR=${VERSION_PARTS[0]}
            MINOR=${VERSION_PARTS[1]}
            PATCH=${VERSION_PARTS[2]}
            PATCH=$((PATCH + 1))
            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
            TAG_NAME="v$NEW_VERSION"
            echo "Generated new tag: $TAG_NAME"
            echo $NEW_VERSION > $VERSION_FILE
            git tag -d "${{ steps.tag_version.outputs.tag_name }}"
            git tag -a "$TAG_NAME" -m "Version $NEW_VERSION"
            echo "::set-output name=tag_name::$TAG_NAME"
          else
            break
          fi
        done
        echo "::set-output name=tag_exists::$TAG_EXISTS"
    - name: Push tag to the repository
      run: |
        git push origin "${{ steps.check_tag.outputs.tag_name }}"
    - name: Publish to GitHub Releases
      uses: ncipollo/release-action@v1
      with:
        artifacts: build/libs/*.jar
        token: ${{ secrets.GITHUB_TOKEN }}
        tag: "${{ steps.check_tag.outputs.tag_name }}"
        name: "Release ${{ steps.check_tag.outputs.tag_name }}"
        body: "Automated release for version ${{ steps.check_tag.outputs.tag_name }}"
